{"name":"CocktailJS","tagline":"Shake your Objects and Classes with Cocktail!","body":"# What's Cocktail?\r\nCocktail is a small library for NodeJS to easily create and define Classes. It helps to reuse code and maintain a simple and clear code structure. \r\n\r\n# For Who?\r\nCocktail is not for everyone. If you feel uncomfortable writing your methods and properties and using _utils_ helpers for inheritance, or you just miss having a better and organised way to read your classes definitions then _CocktailJS_ **is for you**.\r\n\r\nMoreover, if you like OOP and you want to go one step ahead and explore about using **traits** and **talents** to share behaviour, then you'll **love** _CocktailJS_.\r\n\r\n# Keep code simple and yet reusable\r\n_Cocktail_ is **so simple** that it has only _one_ public method: `Cocktail.mix()`\r\n\r\n**Cocktail.mix** accepts two parameters: \r\n\r\n- **subject**: {Class|Object} \r\n- **options**: {Object}\r\n\r\nIn its simplest use case, **mix** will merge your subject with the options. So if you use an Object as a _subject_ and a bunch of properties as _options_, the result will be a merge:\r\n\r\n````\r\nvar obj = {};\r\n\r\nCocktail.mix(obj, {\r\n    aProperty: 'something',\r\n    anotherOne: 'something else'\r\n});\r\n\r\n//now you can access aProperty or anotherOne from obj:\r\nconsole.log(obj.aProperty); //will print 'something'\r\n\r\n````\r\n\r\n## What about all the other cool features?\r\nYes, I mentioned _inheritance_, _traits_, _talents_, blah, blah... Cocktail uses this special properties names that are defined between quotes and start with `@`, those are called `Annotations` and Cocktail uses them to apply some processes to the subject.\r\n\r\n# Annotations\r\nSo, `Annotations`, what ...? Annotations are just some meta-data Cocktail uses to apply some processes. As meta-data they are not part of the resulting mix. Let's explore a bit more about them:\r\n\r\n## `@extends`\r\nFor classical OOP inheritance we need a _Base_ class. `@extends` annotation is used to tell Cocktail that we are going to apply inheritance from a base class. \r\n\r\n````\r\nvar Cocktail = require('Cocktail'),\r\n    BaseClass = require('./MyBaseAwesomeClass'),\r\n    MyClass = function(){};\r\n\r\nCocktail.mix(MyClass, {\r\n    '@extends': BaseClass,\r\n\r\n     someProperty: 'something'\r\n});\r\n\r\n```` \r\n\r\nAs in classical OOP inheritance, any instance of MyClass is an instance of BaseClass too, and you have access to any methods or properties defined in BaseClass.\r\n\r\n## `@properties`\r\nProperties are a kind of magical helper. All the properties defined in @properties become part of the class prototype, but also, it generates getter/setter methods for you.\r\n\r\n````\r\nvar Cocktail = require('Cocktail'),\r\n    BaseClass = require('./MyBaseAwesomeClass'),\r\n    MyClass = function(){};\r\n\r\nCocktail.mix(MyClass, {\r\n    '@extends': BaseClass,\r\n    \r\n     '@properties': {\r\n         name: 'default name'\r\n     },\r\n\r\n     someProperty: 'something'\r\n});\r\n\r\n````\r\n\r\nIn the example above, we will have a `setName` and `getName` methods accessible from any MyClass instance.  \r\n\r\n## `@traits`\r\n_Traits_ are Composable Units of Behaviour (You can read more from [this paper](http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf)). Basically, a Trait is a Class, let's say a special type of Class, that has only behaviour (methods) and no state. \r\n\r\nA Trait can be composed with other Traits. In Cocktail -at least- you cannot extend from a Trait or a Trait cannot extend from other class.\r\n\r\nIn the following example we explore a simple functionality, where we want to know if a given instance is \"testable\" and to resolve that our instance should be an instance of a \"Test\" class.\r\n\r\nWe can create a simple Trait \"Testable\" which will determine if the current instance is testable:\r\n\r\n````\r\nvar TestClass = require('./SomeBaseTest'),\r\n    Testable = function(){};\r\n\r\nTestable.prototype.isTestable = function(){\r\n    return this instanceof TestClass;\r\n};\r\n\r\nmodule.exports = Testable;\r\n````\r\n\r\nSo now we can apply the Testable Trait to our class definition:\r\n\r\n````\r\nvar Cocktail = require('Cocktail'),\r\n    Testable = require('./Testable'),\r\n    MyClass = function(){};\r\n\r\nCocktail.mix(MyClass, {\r\n   '@traits': [Testable],\r\n\r\n   // ... more class definitions\r\n\r\n});\r\n\r\nmodule.exports = MyClass;\r\n````\r\n\r\nNow we can use our class and check if it is Testable\r\n\r\n````\r\nvar MyClass = require('./MyClass'),\r\n    instance;\r\n\r\ninstance = new MyClass();\r\n\r\nconsole.log(instance.isTestable()) //false\r\n````\r\n\r\nThis is a very simple and fairly stupid example, but here we demonstrated we don't need Cocktail to _define_ a Trait but just only to apply it.\r\n\r\n## `@talents`\r\nTalents are very similar to Traits, in fact a Trait can be applied as a Talent in Cocktail. The main difference is a Talent can be applied to an _instance_. So we can define a Talent as a _Dynamically Composable Unit of Reuse_ (you can read more from [this paper](http://scg.unibe.ch/archive/papers/Ress11a-Talents.pdf)).\r\n\r\nIn the previous example we created a Testable trait. So, what now if we want to use that behaviour only on certain instances? Well that's when Talents become super handy:\r\n\r\n````\r\nvar MyClass = require('./MyAnotherClass'),\r\n    MyTestableClass = require('./MyClassInheritsFromTest'),\r\n    Testable = require('./Testable'),\r\n    instanceA, instanceB;\r\n\r\ninstanceA = new MyTestableClass();\r\n\r\nCocktail.mix(instanceA, {\r\n    '@talents': [Testable]\r\n});\r\n\r\nconsole.log(instanceA.isTestable()) //true\r\n\r\ninstanceB = new MyClass();\r\n\r\nCocktail.mix(instanceB, {\r\n    '@talents': [Testable]\r\n})l\r\n\r\nconsole.log(instanceB.isTestable()) //false\r\n\r\n````\r\n","google":"UA-39565774-1","note":"Don't delete this file! It's used internally to help with page regeneration."}