{"name":"CocktailJS","tagline":"Shake your Objects and Classes with Cocktail!","body":"# What's Cocktail?\r\nCocktail is a small library for NodeJS to easily create and define Classes. It helps to reuse code and maintain a simple and clear code structure. \r\n\r\n# For Who?\r\nCocktail is not for everyone. If you feel uncomfortable writing your methods and properties and using _utils_ helpers for inheritance, or you just miss having a better and organised way to read your classes definitions then _CocktailJS_ **is for you**.\r\n\r\nMoreover, if you like OOP and you want to go one step ahead and explore about using **traits** and **talents** to share behaviour, then you'll **love** _CocktailJS_.\r\n\r\n## Keep code simple and yet reusable\r\n_Cocktail_ is **so simple** that it has one _one_ public method: `Cocktail.mix()`\r\n\r\n**Cocktail.mix** accepts two parameters: \r\n\r\n- **subject**: {Class|Object} \r\n- **options**: {Object}\r\n\r\nIn its simplest use case, **mix** will merge your subject with the options. So if you use an Object as a _subject_ and a bunch of properties as _options_, the result will be a merge:\r\n\r\n````\r\nvar obj = {};\r\n\r\nCocktail.mix(obj, {\r\n    aProperty: 'something',\r\n    anotherOne: 'something else'\r\n});\r\n\r\n//now you can access aProperty or anotherOne from obj:\r\nconsole.log(obj.aProperty); //will print 'something'\r\n\r\n````\r\n\r\n## What about all the cool other features?\r\nYes, I mentioned _inheritance_, _traits_, _talents_, blah, blah... Cocktail uses this special properties names that are defined between quotes and start with `@`, those are called `Annotations` and Cocktail uses them to apply some processes to the subject.\r\n\r\n# Annotations\r\nSo, `Annotations`, what ...? Annotations are just some meta-data Cocktail uses to apply some processes. As meta-data they are not part of the resulting mix. Let's explore a bit more about them:\r\n\r\n## `@extends`\r\nFor classical OOP inheritance we need a _Base_ class. `@extends` annotation is used to tell Cocktail that we are going to apply inheritance from a base class. \r\n\r\n````\r\nvar Cocktail = require('Cocktail'),\r\n    BaseClass = require('./MyBaseAwesomeClass'),\r\n    MyClass = function(){};\r\n\r\nCocktail.mix(MyClass, {\r\n    '@extends': BaseClass,\r\n\r\n     someProperty: 'something'\r\n});\r\n\r\n```` \r\n\r\nAs in classical OOP inheritance, any instance of MyClass is an instance of BaseClass too, and you have access to any methods or properties defined in BaseClass.\r\n\r\n## `@properties`\r\nProperties are a kind of magical helper. All the properties defined in @properties become part of the class prototype, but also, it generates getter/setter methods for you.\r\n\r\n````\r\nvar Cocktail = require('Cocktail'),\r\n    BaseClass = require('./MyBaseAwesomeClass'),\r\n    MyClass = function(){};\r\n\r\nCocktail.mix(MyClass, {\r\n    '@extends': BaseClass,\r\n    \r\n     '@properties': {\r\n         name: 'default name'\r\n     },\r\n\r\n     someProperty: 'something'\r\n});\r\n\r\n````\r\n\r\nIn the example above, we will have a `setName` and `getName` methods accessible from any MyClass instance.  \r\n\r\n## `@traits`\r\n_Traits_ are Composable Units of Behaviour (You can read more from [this paper](http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf)). Basically, a Trait is a Class, let's say a special type of Class, that has only behaviour (methods) and no state. \r\n\r\nA Trait can be composed with other Traits. In Cocktail -at least- you cannot extend from a Trait or a Trait cannot extend from other class.\r\n\r\n````\r\n\r\n````","google":"UA-39565774-1","note":"Don't delete this file! It's used internally to help with page regeneration."}