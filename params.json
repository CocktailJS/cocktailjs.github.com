{"name":"CocktailJS","tagline":"Shake your Objects and Classes with Cocktail!","body":"# What's Cocktail?\r\nCocktail is a small library for NodeJS to easily create and define Classes. It helps to reuse code and to maintain a simple and clear code structure. \r\n\r\n# For Who?\r\nCocktail is not for everyone. If you feel uncomfortable writing your methods and properties and using _utils_ helpers for inheritance, or you just miss having a better and organised way to read your classes definitions, or you believe that a 'util' is a code smell, then _CocktailJS_ **is for you**.\r\n\r\nMoreover, if you like OOP and you want to go one step ahead and explore about using **traits** and **talents** to share behaviour, then you'll **love** _Cocktail_.\r\n\r\n# Keep code simple yet reusable\r\n_Cocktail_ is **so simple** that it has only _one_ public method: `Cocktail.mix()`\r\n\r\n**Cocktail.mix** accepts two parameters: \r\n\r\n- **subject**: {Class|Object} \r\n- **options**: {Object}\r\n\r\nIn its simplest use case, **mix** will merge your subject with the options. So if you use an Object as a _subject_ and a bunch of properties as _options_, the result will be a merge:\r\n\r\n````\r\nvar obj = {};\r\n\r\nCocktail.mix(obj, {\r\n    aProperty: 'something',\r\n    anotherOne: 'something else'\r\n});\r\n\r\n//now you can access aProperty or anotherOne from obj:\r\nconsole.log(obj.aProperty); //will print 'something'\r\n\r\n````\r\n\r\n## What about all the other cool features?\r\nYes, I mentioned _inheritance_, _traits_, _talents_, blah, blah... Cocktail uses these special properties names that are defined between quotes and start with `@`, those are called `Annotations` in Cocktail.\r\n\r\n# Annotations\r\nSo, `Annotations`, what ...? Annotations are just some meta-data Cocktail uses to apply some processes. As meta-data, they are not part of the resulting mix. Let's explore a bit more about them:\r\n\r\n## `@extends`\r\nFor classical OOP inheritance we need a _Base_ class. `@extends` annotation is used to tell Cocktail that we are going to apply inheritance from a base class. \r\n\r\n````\r\nvar Cocktail = require('Cocktail'),\r\n    BaseClass = require('./MyBaseAwesomeClass'),\r\n    MyClass = function(){};\r\n\r\nCocktail.mix(MyClass, {\r\n    '@extends': BaseClass,\r\n\r\n     someProperty: 'something'\r\n});\r\n\r\n```` \r\n\r\nAs in classical OOP inheritance, any instance of MyClass is an instance of BaseClass too, and you have access to any methods or properties defined in BaseClass.\r\n\r\n## `@properties`\r\nProperties are a kind of magical helper. All the properties defined in @properties become part of the class prototype, but also, it generates getter/setter methods for you.\r\n\r\n````\r\nvar Cocktail = require('Cocktail'),\r\n    BaseClass = require('./MyBaseAwesomeClass'),\r\n    MyClass = function(){};\r\n\r\nCocktail.mix(MyClass, {\r\n    '@extends': BaseClass,\r\n    \r\n     '@properties': {\r\n         name: 'default name',\r\n         valid: true\r\n     },\r\n\r\n     someProperty: 'something'\r\n});\r\n\r\n````\r\n\r\nIn the example above, we will have a `setName` and `getName` methods accessible from any MyClass instance.  \r\nIn case the property is a _boolean_ like `valid`, then we will have an `isValid` and `setValid` methods instead. \r\n\r\n## `@traits`\r\n_Traits_ are Composable Units of Behaviour (You can read more from [this paper](http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf)). Basically, a Trait is a Class, let's say a special type of Class, that has only behaviour (methods) and no state. \r\n\r\nA Trait can be composed with other Traits. In Cocktail -at least- you cannot extend from a Trait or a Trait cannot extend from other class.\r\n\r\nIn the following example we explore a simple functionality, where we want to know if a given instance is \"testable\" and to resolve that our instance should be an instance of a \"Test\" class.\r\n\r\nWe can create a simple Trait \"Testable\" which will determine if the current instance is testable:\r\n\r\n````\r\nvar TestClass = require('./SomeBaseTest'),\r\n    Testable = function(){};\r\n\r\nTestable.prototype.isTestable = function(){\r\n    return this instanceof TestClass;\r\n};\r\n\r\nmodule.exports = Testable;\r\n````\r\n\r\nSo now we can apply the Testable Trait to our class definition:\r\n\r\n````\r\nvar Cocktail = require('Cocktail'),\r\n    Testable = require('./Testable'),\r\n    MyClass = function(){};\r\n\r\nCocktail.mix(MyClass, {\r\n   '@traits': [Testable],\r\n\r\n   // ... more class definitions\r\n\r\n});\r\n\r\nmodule.exports = MyClass;\r\n````\r\n\r\nNow we can use our class and check if it is Testable\r\n\r\n````\r\nvar MyClass = require('./MyClass'),\r\n    instance;\r\n\r\ninstance = new MyClass();\r\n\r\nconsole.log(instance.isTestable()); //false\r\n````\r\n\r\nThis is a very simple and fairly stupid example, but here we demonstrated we don't need Cocktail to _define_ a Trait but just only to apply it.\r\n\r\nIf you have read the paper, you might noticed that sometimes conflicts may arise and there are some ways to avoid those conflicts. Those are implemented in _Cocktail_ as well. You can create _alias_ or even _exclude_ methods from the Trait. The syntax is a bit different for these cases:\r\n\r\n````\r\nCocktail.mix(MyClass, {\r\n   '@traits': [\r\n       Testable,\r\n       {\r\n           trait: AnotherTrait,\r\n           excludes: ['doSomething'], \r\n           alias: {\r\n              'methodFoo': 'myClassMethodFoo'\r\n           }\r\n       }\r\n    ],\r\n\r\n   // ... more class definitions\r\n\r\n});\r\n````\r\n\r\n## `@requires`\r\nWe saw that we can use any Class defined with no state as a Trait but, sometimes we need to specify that our Trait requires some methods to be defined in order to be usable. That's what `@requires` is for. Let's see an example:\r\n\r\nOur Trait _Formatable_ requires a value where the format will be applied. Since Traits _cannot have state_, we need some way to access to the variable we want to format. So, in this case _Formatable_ requires a _getValue_ method to be defined:\r\n\r\n````\r\nCocktail.mix(Formatable, {\r\n    '@requires': ['getValue'],\r\n\r\n    format: function(pattern){\r\n         var value = this.getValue(); \r\n         // apply the pattern to the current value ...\r\n         return value;\r\n    }\r\n});\r\n```` \r\n\r\nNow we can apply it to a Class:\r\n\r\n````\r\nCocktail.mix(MyClass, {\r\n   '@traits': [Formatable],\r\n   '@properties': {\r\n       value: 10\r\n   }\r\n});\r\n````\r\n\r\nNote that we have not defined a `getValue()` method which is required by our trait, but have used the properties annotation which will generate the getter for us. So in this case the __Class + glue code + Trait__ trilogy is successfully completed. \r\n\r\n## `@talents`\r\nTalents are very similar to Traits, in fact a Trait can be applied as a Talent in Cocktail. The main difference is a Talent can be applied to an _instance_. So we can define a Talent as a _Dynamically Composable Unit of Reuse_ (you can read more from [this paper](http://scg.unibe.ch/archive/papers/Ress11a-Talents.pdf)).\r\n\r\nIn a previous example we have created a Testable trait. So, what if we want now to use that behaviour only on certain instances? Well that's when Talents become super handy:\r\n\r\n````\r\nvar MyClass = require('./MyAnotherClass'),\r\n    MyTestableClass = require('./MyClassInheritsFromTestClass'),\r\n    Testable = require('./Testable'),\r\n    instanceA, instanceB;\r\n\r\ninstanceA = new MyTestableClass();\r\n\r\nCocktail.mix(instanceA, {\r\n    '@talents': [Testable]\r\n});\r\n\r\nconsole.log(instanceA.isTestable()); //true\r\n\r\ninstanceB = new MyClass();\r\n\r\nCocktail.mix(instanceB, {\r\n    '@talents': [Testable]\r\n});\r\n\r\nconsole.log(instanceB.isTestable()); //false\r\n\r\n````\r\n\r\nThe same syntax we used for Traits is applicable to a Talent for _excludes_ and _alias_ functionality. \r\n","google":"UA-39565774-1","note":"Don't delete this file! It's used internally to help with page regeneration."}