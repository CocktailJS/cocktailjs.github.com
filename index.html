<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="CocktailJS : Shake your Objects and Classes with Cocktail!" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>CocktailJS</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/CocktailJS">View on GitHub</a>

          <h1 id="project_title">CocktailJS</h1>
          <h2 id="project_tagline">Shake your Objects and Classes with Cocktail!</h2>

        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <h1>What's Cocktail?</h1>

<p>Cocktail is a small library for NodeJS to easily create and define Classes. It helps to reuse code and to maintain a simple and clear code structure. </p>

<h1>For Who?</h1>

<p>Cocktail is not for everyone. If you feel uncomfortable writing your methods and properties and using <em>utils</em> helpers for inheritance, or you just miss having a better and organised way to read your classes definitions, or you believe that a 'util' is a code smell, then <em>CocktailJS</em> <strong>is for you</strong>.</p>

<p>Moreover, if you like OOP and you want to go one step ahead and explore about using <strong>traits</strong> and <strong>talents</strong> to share behaviour, then you'll <strong>love</strong> <em>Cocktail</em>.</p>

<h1>Keep code simple yet reusable</h1>

<p><em>Cocktail</em> is <strong>so simple</strong> that it has only <em>one</em> public method: <code>Cocktail.mix()</code></p>

<p><strong>Cocktail.mix</strong> accepts two parameters: </p>

<ul>
<li>
<strong>subject</strong>: {Class|Object} </li>
<li>
<strong>options</strong>: {Object}</li>
</ul><p>In its simplest use case, <strong>mix</strong> will merge your subject with the options. So if you use an Object as a <em>subject</em> and a bunch of properties as <em>options</em>, the result will be a merge:</p>

<pre><code>var obj = {};

Cocktail.mix(obj, {
    aProperty: 'something',
    anotherOne: 'something else'
});

//now you can access aProperty or anotherOne from obj:
console.log(obj.aProperty); //will print 'something'

</code></pre>

<h2>What about all the other cool features?</h2>

<p>Yes, I mentioned <em>inheritance</em>, <em>traits</em>, <em>talents</em>, blah, blah... Cocktail uses this special properties names that are defined between quotes and start with <code>@</code>, those are called <code>Annotations</code> and Cocktail uses them to apply some processes to the subject.</p>

<h1>Annotations</h1>

<p>So, <code>Annotations</code>, what ...? Annotations are just some meta-data Cocktail uses to apply some processes. As meta-data they are not part of the resulting mix. Let's explore a bit more about them:</p>

<h2><code>@extends</code></h2>

<p>For classical OOP inheritance we need a <em>Base</em> class. <code>@extends</code> annotation is used to tell Cocktail that we are going to apply inheritance from a base class. </p>

<pre><code>var Cocktail = require('Cocktail'),
    BaseClass = require('./MyBaseAwesomeClass'),
    MyClass = function(){};

Cocktail.mix(MyClass, {
    '@extends': BaseClass,

     someProperty: 'something'
});

</code></pre>

<p>As in classical OOP inheritance, any instance of MyClass is an instance of BaseClass too, and you have access to any methods or properties defined in BaseClass.</p>

<h2><code>@properties</code></h2>

<p>Properties are a kind of magical helper. All the properties defined in @properties become part of the class prototype, but also, it generates getter/setter methods for you.</p>

<pre><code>var Cocktail = require('Cocktail'),
    BaseClass = require('./MyBaseAwesomeClass'),
    MyClass = function(){};

Cocktail.mix(MyClass, {
    '@extends': BaseClass,

     '@properties': {
         name: 'default name'
     },

     someProperty: 'something'
});

</code></pre>

<p>In the example above, we will have a <code>setName</code> and <code>getName</code> methods accessible from any MyClass instance.  </p>

<h2><code>@traits</code></h2>

<p><em>Traits</em> are Composable Units of Behaviour (You can read more from <a href="http://scg.unibe.ch/archive/papers/Scha03aTraits.pdf">this paper</a>). Basically, a Trait is a Class, let's say a special type of Class, that has only behaviour (methods) and no state. </p>

<p>A Trait can be composed with other Traits. In Cocktail -at least- you cannot extend from a Trait or a Trait cannot extend from other class.</p>

<p>In the following example we explore a simple functionality, where we want to know if a given instance is "testable" and to resolve that our instance should be an instance of a "Test" class.</p>

<p>We can create a simple Trait "Testable" which will determine if the current instance is testable:</p>

<pre><code>var TestClass = require('./SomeBaseTest'),
    Testable = function(){};

Testable.prototype.isTestable = function(){
    return this instanceof TestClass;
};

module.exports = Testable;
</code></pre>

<p>So now we can apply the Testable Trait to our class definition:</p>

<pre><code>var Cocktail = require('Cocktail'),
    Testable = require('./Testable'),
    MyClass = function(){};

Cocktail.mix(MyClass, {
   '@traits': [Testable],

   // ... more class definitions

});

module.exports = MyClass;
</code></pre>

<p>Now we can use our class and check if it is Testable</p>

<pre><code>var MyClass = require('./MyClass'),
    instance;

instance = new MyClass();

console.log(instance.isTestable()) //false
</code></pre>

<p>This is a very simple and fairly stupid example, but here we demonstrated we don't need Cocktail to <em>define</em> a Trait but just only to apply it.</p>

<h2><code>@talents</code></h2>

<p>Talents are very similar to Traits, in fact a Trait can be applied as a Talent in Cocktail. The main difference is a Talent can be applied to an <em>instance</em>. So we can define a Talent as a <em>Dynamically Composable Unit of Reuse</em> (you can read more from <a href="http://scg.unibe.ch/archive/papers/Ress11a-Talents.pdf">this paper</a>).</p>

<p>In the previous example we created a Testable trait. So, what now if we want to use that behaviour only on certain instances? Well that's when Talents become super handy:</p>

<pre><code>var MyClass = require('./MyAnotherClass'),
    MyTestableClass = require('./MyClassInheritsFromTest'),
    Testable = require('./Testable'),
    instanceA, instanceB;

instanceA = new MyTestableClass();

Cocktail.mix(instanceA, {
    '@talents': [Testable]
});

console.log(instanceA.isTestable()) //true

instanceB = new MyClass();

Cocktail.mix(instanceB, {
    '@talents': [Testable]
})l

console.log(instanceB.isTestable()) //false

</code></pre>
      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

              <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-39565774-1");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>


  </body>
</html>
